package etcdqueue

import (
	"fmt"
	"path"
	"time"
)

const (
	// MaxWeight is the maximum value for item(job) weights.
	MaxWeight uint64 = 99999

	// MaxProgress is the progress value when the job is done!
	MaxProgress = 100
)

// Item represents a job item in the queue. Key is stored as a key,
// with serialized JSON data as a value.
type Item struct {
	// Bucket is the name or job category for namespacing.
	// All keys will be prefixed with bucket name.
	Bucket string `json:"bucket"`

	// CreatedAt is timestamp of item creation.
	CreatedAt time.Time `json:"created_at"`

	// Key is autogenerated based on timestamps and bucket name.
	// It is stored as a key in etcd.
	Key string `json:"key"`

	// Value contains any data (e.g. encoded computation results).
	Value string `json:"value"`

	// Progress is the progress status value (range from 0 to 'etcdqueue.MaxProgress').
	Progress int `json:"progress"`

	// Canceled is true if the item(or job) is canceled.
	Canceled bool `json:"canceled"`

	// Error contains any error message. It's defined as string for
	// different language interpolation.
	Error string `json:"error"`

	// RequestID is used/generated by external service,
	// to help identify each item.
	RequestID string `json:"request_id"`
}

// CreateItem creates an item with auto-generated ID of unix nano seconds.
// The maximum weight(priority) is 99999.
func CreateItem(bucket string, weight uint64, value string) *Item {
	if weight > MaxWeight {
		weight = MaxWeight
	}

	// maximum weight comes first, lexicographically
	priority := 99999 - weight
	return &Item{
		Bucket:    bucket,
		CreatedAt: time.Now(),
		Key:       path.Join(bucket, fmt.Sprintf("%05d%035X", priority, time.Now().UnixNano())),
		Value:     value,
		Progress:  0,
		Error:     "",
	}
}

// Equal compares two items with truncated CreatedAt field string,
// to handle modified timestamp string after serialization
func (item1 *Item) Equal(item2 *Item) error {
	if item1.CreatedAt.String()[:29] != item2.CreatedAt.String()[:29] {
		return fmt.Errorf("expected CreatedAt %q, got %q", item1.CreatedAt.String()[:29], item2.CreatedAt.String()[:29])
	}
	if item1.Bucket != item2.Bucket {
		return fmt.Errorf("expected Bucket %q, got %q", item1.Bucket, item2.Bucket)
	}
	if item1.Key != item2.Key {
		return fmt.Errorf("expected Key %q, got %q", item1.Key, item2.Key)
	}
	if item1.Value != item2.Value {
		return fmt.Errorf("expected Value %q, got %q", item1.Value, item2.Value)
	}
	if item1.Progress != item2.Progress {
		return fmt.Errorf("expected Progress %d, got %d", item1.Progress, item2.Progress)
	}
	if item1.Canceled != item2.Canceled {
		return fmt.Errorf("expected Canceled %v, got %v", item1.Canceled, item2.Canceled)
	}
	if item1.Error != item2.Error {
		return fmt.Errorf("expected Error %s, got %s", item1.Error, item2.Error)
	}
	if item1.RequestID != item2.RequestID {
		return fmt.Errorf("expected RequestID %s, got %s", item1.RequestID, item2.RequestID)
	}
	return nil
}

// ItemWatcher is receive-only channel, used for broadcasting status updates.
type ItemWatcher <-chan *Item
